#! /usr/bin/env python
from pyglet.window import key
import pyglet
import time
import sys
import curses

def col_major(alist, sublen):
	#turns list to nested list (matrix)
	numrows = (len(alist)+sublen-1) // sublen
	return [alist[i::sublen] for i in range(numrows)]

def html_table(nested):
	#turns nested table into html
	html = '<table>\n'
	for sublist in nested:
		html += '  <tr><td>\n'
		html += '    </td><td>\n'.join(sublist)
		html += '  </td></tr>\n'
	html += '</table>'
	return html

cmdD={		'1000':'ADD',
		'1001':'SHR',
		'1010':'SHL',
		'1011':'NOT',
		'1100':'AND',
		'1101':'OR',
		'1110':'XOR',
		'1111':'CMP',
		'0000':'LOAD',
		'0001':'STORE',
		'0010':'DATA',
		'0011':'JMPR',
		'0100':'JMP',
		'0101':'JMPIF',
		'0110':'CLF',
		'0111':'OUT',
		}
BIN = {'00':0,'01':1,'10':2,'11':3}

def translate(cmd):
	out = []
	try:	out.append(cmdD[cmd[:4]])
	except: out.append('')
	if out[0]=='JMPIF':
		out = out+filter(lambda x: x!='0',[b if a=='1' else '0' for a,b in zip(cmd[4:8],list('CAEZ'))])
	else:
		try:	out.append(BIN[cmd[4:6]])
		except: out.append('')
		try:	out.append(BIN[cmd[6:8]])
		except: out.append('')
	return out

instructions='''1000 ADD   RA,RB
1001 SHR   RA,RB
1010 SHL   RA,RB
1011 NOT   RA,RB
1100 AND   RA,RB
1101 OR    RA,RB
1110 XOR   RA,RB
1111 CMP   RA,RB
0000 LD    RA,RB
0001 ST    RA,RB
0010 DATA  RB,DATA
0011 JUMPR RB
0100 JMP   Addr
0101 JMPIF CAEZ,Addr
0110 CLF
0111 OUT  RA
'''


class CPU:
	pass
	def __init__(self,file=None):
		if file == None: self.RAM = ['0'*8]*(2**8)
		else: 		 self.RAM = self.load(file)
		self.fontSize = 14
		self.speed = 1.0
		self.STEP = 0
		self.output = []
		self.cursorPos = 0
		self.IAR = 0
		self.IR = '0'*8
		#RAM = ['0'*8]*2**8
		play=False
		t0 = time.clock()
		self.registers = [	'00000000',
					'00000000',
					'00000000',
					'00000000']
		self.ACC = '0'*8
		self.flags = {'C':0,'A':0,'E':0,'Z':0}
		self.highlighted  = 0
		#myscreen = curses.initscr()
		#curses.cbreak()

	def load(self,file):
		ram = open(f).read().split('\n')[:-1]
		if len(ram)>2**8:
			raise Exception('program too long, no more than 255 instructions')
			sys.exit()
		if filter(lambda x: len(x)!=8,ram)!=[]:
			raise Exception('not all commands are 8 bit')
			sys.exit()
		return ram

	def step(self):
		self.STEP += 1
		self.CMD = translate(self.RAM[self.IAR])
		if self.CMD[0]=='ADD':
			a = int(self.registers[self.CMD[1]],2)
			b = int(self.registers[self.CMD[2]],2)
			x = str(bin(a+b)).split('b')[-1]
			if len(x)>8:
				self.flags['C']=1
				self.registers[self.CMD[2]]=x[-8:]
			else:
				self.registers[self.CMD[2]]=x.rjust(8,'0')
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='SHR':
			self.registers[self.CMD[2]] = ('0'+self.registers[self.CMD[1]])[:8]
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='SHL':
			self.registers[self.CMD[2]] = (self.registers[self.CMD[1]])+'0'[-8:]
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='NOT':
			self.registers[self.CMD[2]]= ''.join(['1' if x=='0' else '0' for x in  self.registers[self.CMD[1]] ])
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='AND':
			self.registers[self.CMD[2]]= ''.join(['1' if a+b=='11' else '0' for a,b in  zip(self.registers[self.CMD[1]],self.registers[self.CMD[2]]) ])
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='OR':
			self.registers[self.CMD[2]]= ''.join(['1' if '1' in [a,b] else '0' for a,b in  zip(self.registers[self.CMD[1]],self.registers[self.CMD[2]]) ])
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='XOR':
			self.registers[self.CMD[2]]= ''.join(['1' if a+b in ['10','01'] else '0' for a,b in  zip(self.registers[self.CMD[1]],self.registers[self.CMD[2]]) ])
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='CMP':
			a = self.registers[self.CMD[1]]
			b = self.registers[self.CMD[2]]
			if a==b: 		self.flags['E']='1'
			if int(a,2)>int(b,2):	self.flags['A']='1'
			if a == '0'*8:		self.flags['Z']='1'
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='LOAD':
			self.registers[self.CMD[2]] = self.RAM[int(self.registers[self.CMD[1]],2)]
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='STORE':
			self.RAM[int(self.registers[self.CMD[1]],2)] = self.registers[self.CMD[2]]
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='DATA':
			self.registers[self.CMD[1]]=self.RAM[(self.IAR+1)%2**8]
                	self.IAR += 2
                	self.IAR  = self.IAR%2**8
		if self.CMD[0]=='JMPR':
			self.IAR = int(self.registers[self.CMD[2]],2)
		if self.CMD[0]=='JMP':
			self.IAR = int(self.RAM[(self.IAR+1)%2**8],2)
		if self.CMD[0]=='JMPIF':
			for flag in self.CMD[1:]:
				if self.flags[flag]=='1':
					self.IAR = int(self.RAM[(self.IAR+1)%2**8],2)
					return None
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='CLF':
			self.flags = {'C':0,'A':0,'E':0,'Z':0}
			self.IAR += 1
			self.IAR  = self.IAR%2**8
		if self.CMD[0]=='OUT':
			output.append(self.registers[self.CMD[1]])
			self.IAR += 1
			self.IAR  = self.IAR%2**8

	def refreshScreen(self,text =''):
		'''
		myscreen.keypad(1)
		myscreen.border(0)
		#myscreen.addstr(1, 25, "Python curses in action!")
		myscreen.addstr(1, 2, 'IAR:  '+str(IAR)+'    ')
		myscreen.addstr(2, 2, 'Step: '+str(STEP)+'    ')
		myscreen.addstr(1, 20, '\t'.join(map(str,translate(RAM[IAR]))).rjust(30,' '))
		for i in range(16):
			for j in range(16):
				n= i+16*j
				myscreen.addstr(i*2+3, j*9+2, str(n))
				if n==IAR:
					myscreen.addstr(i*2+4, j*9+2, RAM[n],curses.A_BOLD)
					myscreen.addstr(i*2+4,j*9+2+cursorPos, RAM[n][cursorPos])
				elif n==highlighted:
					myscreen.addstr(i*2+4, j*9+2, RAM[n],curses.A_STANDOUT)
					myscreen.addstr(i*2+4,j*9+2+cursorPos, RAM[n][cursorPos])
				else:
					myscreen.addstr(i*2+4, j*9+2, RAM[n])
		for i in range(4): #print registers
			myscreen.addstr(i+16*2+4, 2, 'R'+str(i)+':  '+registers[i])
		#myscreen.addstr(36, 2, 'IR:  '+IR)
		for n,flag in enumerate(list('CAEZ')):
			myscreen.addstr(n+16*2+4, 16, flag+': '+str(flags[flag]))
		for n,line in enumerate(instructions.split('\n')):
			myscreen.addstr(n%4+16*2+4, 50+20*(n/4), line.replace(' ',':'))
		cmds = translate(RAM[highlighted])
		myscreen.addstr(36,24, ' '.join(map(str,cmds)) +'     ')
		myscreen.addstr(37,24, str( int(RAM[highlighted],2)  )  +'     ')
        	curses.setsyx(1,1)
		myscreen.addstr(1,120, str(text)+'      ')
		myscreen.addstr(1,100, 'speed: '+str(speed)+'      ')
		for n,out in enumerate(output[-15:][::-1]):
			myscreen.addstr(2+n,147,out)
		myscreen.refresh()
		'''

	def play(self,keyPress):
		prevHighlighted = self.highlighted
		if   keyPress == key.UP:
			self.highlighted -= 1
		elif keyPress == key.DOWN:
			self.highlighted += 1
		elif keyPress == key.LEFT:
			self.highlighted -= 2**4
		elif keyPress == key.RIGHT:
			self.highlighted += 2**4

		elif keyPress in (key.NUM_0,key.NUM_1): # ZERO,one
			cmd = list(self.RAM[self.highlighted])
			if key == 48: cmd[self.cursorPos]='0'
			else: 	      cmd[self.cursorPos]='1'
			self.RAM[self.highlighted]=''.join(cmd)
			self.cursorPos+=1
		elif keyPress == key.BACKSPACE:
			if self.cursorPos>0:self.cursorPos-=1
		if self.cursorPos>=8:
			self.cursorPos=0
			self.highlighted +=1
		if prevHighlighted != self.highlighted:
			self.cursorPos = 0

		if keyPress == key.ENTER: #ENTER
			self.step()
		if keyPress == key.R: #r reset
			self.IAR = 0
			self.IR  = '0'*8
			self.STEP = 0
			#RAM = ['0'*8]*2**8
			self.registers = ['00000000',
					'00000000',
					'00000000',
					'00000000']
			self.ACC = '0'*8
			self.flags = {'C':0,'A':0,'E':0,'Z':0}
		if keyPress == key.S: #s save ram to same file used to upload
			file = 'tmp.ram'
			#file = raw_input('filename: ['+f+']: ')
			if file =='': file = f
			F = open(file,'w')
			F.write('\n'.join(self.RAM))
			F.close()
		if keyPress == key.PLUS: #+
			self.speed = self.speed * 2
		if keyPress == key.MINUS: #-
			self.speed = self.speed / 2
		if keyPress == key.SPACE: #space
			self.play = not(self.play)
		self.highlighted = self.highlighted % 2**8
game = CPU()
window = pyglet.window.Window()
@window.event
def on_draw():
	window.clear()
	pyglet.text.Label(
		'<font color="red">'+html_table(col_major(game.RAM,16))+'</font>',
		x=window.width//2, y=window.height//2,
		anchor_x='center', anchor_y='center',
		).draw()


@window.event
def on_key_press(symbol, modifiers):
	game.play(symbol)
pyglet.app.run()

